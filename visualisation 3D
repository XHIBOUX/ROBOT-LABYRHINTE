<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot Cherokey dans un Labyrinthe 2D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #f0f0f0; }
        canvas { border: 1px solid black; }
    </style>
</head>
<body>
    <script>
        let robot;
        let walls = [];
        let cols, rows;
        const resolution = 40;

        class Robot {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = resolution / 2;
                this.speed = resolution / 4;
                this.dir = createVector(1, 0);
                this.path = [];
                this.target = createVector((cols - 1) * resolution, (rows - 1) * resolution);
            }

            move() {
                let nextX = this.x + this.dir.x * this.speed;
                let nextY = this.y + this.dir.y * this.speed;

                // Collision detection
                if (this.collides(nextX, nextY)) {
                    this.dir.rotate(HALF_PI);
                } else {
                    this.x = nextX;
                    this.y = nextY;
                    this.path.push(createVector(this.x, this.y));

                    if (this.path.length > 50) {
                        this.path.shift();
                    }
                }

                // Check if the robot reaches the target
                if (dist(this.x, this.y, this.target.x, this.target.y) < this.size / 2) {
                    noLoop(); // Stop the draw loop
                    alert("Le robot a trouvé la sortie !");
                }
            }

            show() {
                fill(255, 0, 0);
                noStroke();
                ellipse(this.x, this.y, this.size, this.size);

                // Show the path
                noFill();
                stroke(255, 0, 0);
                beginShape();
                for (let pos of this.path) {
                    vertex(pos.x, pos.y);
                }
                endShape();
            }

            collides(nextX, nextY) {
                for (let wall of walls) {
                    if (nextX + this.size / 2 > wall.x &&
                        nextX - this.size / 2 < wall.x + wall.w &&
                        nextY + this.size / 2 > wall.y &&
                        nextY - this.size / 2 < wall.y + wall.h) {
                        return true;
                    }
                }
                return false;
            }
        }

        class Wall {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }

            show() {
                fill(0, 0, 255);
                noStroke();
                rect(this.x, this.y, this.w, this.h);
            }
        }

        function setup() {
            createCanvas(800, 800);
            cols = floor(width / resolution);
            rows = floor(height / resolution);

            // Création du robot
            robot = new Robot(resolution / 2, resolution / 2);

            // Création des murs du labyrinthe
            createMaze();
        }

        function draw() {
            background(240);

            // Affichage et mouvement du robot
            robot.move();
            robot.show();

            // Affichage des murs
            for (let wall of walls) {
                wall.show();
            }
        }

        function createMaze() {
            // Bordures du labyrinthe
            walls.push(new Wall(0, 0, width, resolution)); // Haut
            walls.push(new Wall(0, height - resolution, width, resolution)); // Bas
            walls.push(new Wall(0, 0, resolution, height)); // Gauche
            walls.push(new Wall(width - resolution, 0, resolution, height)); // Droite

            // Murs internes
            for (let i = 1; i < cols - 1; i++) {
                for (let j = 1; j < rows - 1; j++) {
                    if (random(1) < 0.3) {
                        walls.push(new Wall(i * resolution, j * resolution, resolution, resolution));
                    }
                }
            }
        }
    </script>
</body>
</html>
